{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\PathUtils.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\LocationUtils.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\createTransitionManager.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\DOMUtils.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\createBrowserHistory.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\createHashHistory.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\createMemoryHistory.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\es\\\\index.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\history\\\\node_modules\\\\warning\\\\browser.js\"],\"names\":[\"addLeadingSlash\",\"path\",\"charAt\",\"hasBasename\",\"prefix\",\"RegExp\",\"test\",\"stripBasename\",\"substr\",\"length\",\"stripTrailingSlash\",\"slice\",\"createPath\",\"location\",\"pathname\",\"search\",\"hash\",\"_extends\",\"Object\",\"assign\",\"target\",\"i\",\"arguments\",\"source\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"LocationUtils_createLocation\",\"state\",\"currentLocation\",\"hashIndex\",\"indexOf\",\"searchIndex\",\"parsePath\",\"undefined\",\"decodeURI\",\"e\",\"URIError\",\"resolve_pathname\",\"LocationUtils_locationsAreEqual\",\"a\",\"b\",\"value_equal\",\"es_createTransitionManager\",\"prompt\",\"listeners\",\"setPrompt\",\"nextPrompt\",\"browser_default\",\"confirmTransitionTo\",\"action\",\"getUserConfirmation\",\"callback\",\"result\",\"appendListener\",\"fn\",\"isActive\",\"listener\",\"apply\",\"push\",\"filter\",\"item\",\"notifyListeners\",\"_len\",\"args\",\"Array\",\"_key\",\"forEach\",\"canUseDOM\",\"window\",\"document\",\"createElement\",\"addEventListener\",\"node\",\"event\",\"attachEvent\",\"removeEventListener\",\"detachEvent\",\"getConfirmation\",\"message\",\"confirm\",\"_typeof\",\"Symbol\",\"iterator\",\"obj\",\"constructor\",\"createBrowserHistory_extends\",\"getHistoryState\",\"history\",\"es_createBrowserHistory\",\"props\",\"invariant_browser_default\",\"ua\",\"globalHistory\",\"canUseHistory\",\"navigator\",\"userAgent\",\"needsHashChangeListener\",\"_props$forceRefresh\",\"forceRefresh\",\"_props$getUserConfirm\",\"_props$keyLength\",\"keyLength\",\"basename\",\"getDOMLocation\",\"historyState\",\"_ref\",\"_window$location\",\"createKey\",\"Math\",\"random\",\"toString\",\"transitionManager\",\"setState\",\"nextState\",\"handlePopState\",\"isExtraneousPopstateEvent\",\"handlePop\",\"handleHashChange\",\"forceNextPop\",\"ok\",\"revertPop\",\"fromLocation\",\"toLocation\",\"toIndex\",\"allKeys\",\"fromIndex\",\"delta\",\"go\",\"initialLocation\",\"createHref\",\"n\",\"listenerCount\",\"checkDOMListeners\",\"isBlocked\",\"href\",\"pushState\",\"prevIndex\",\"nextKeys\",\"replace\",\"replaceState\",\"goBack\",\"goForward\",\"block\",\"unblock\",\"listen\",\"unlisten\",\"__webpack_require__\",\"d\",\"__webpack_exports__\",\"module\",\"exports\"],\"mappings\":\"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\",\"sourcesContent\":[\"export var addLeadingSlash = function addLeadingSlash(path) {\\n  return path.charAt(0) === '/' ? path : '/' + path;\\n};\\n\\nexport var stripLeadingSlash = function stripLeadingSlash(path) {\\n  return path.charAt(0) === '/' ? path.substr(1) : path;\\n};\\n\\nexport var hasBasename = function hasBasename(path, prefix) {\\n  return new RegExp('^' + prefix + '(\\\\\\\\/|\\\\\\\\?|#|$)', 'i').test(path);\\n};\\n\\nexport var stripBasename = function stripBasename(path, prefix) {\\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\\n};\\n\\nexport var stripTrailingSlash = function stripTrailingSlash(path) {\\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\\n};\\n\\nexport var parsePath = function parsePath(path) {\\n  var pathname = path || '/';\\n  var search = '';\\n  var hash = '';\\n\\n  var hashIndex = pathname.indexOf('#');\\n  if (hashIndex !== -1) {\\n    hash = pathname.substr(hashIndex);\\n    pathname = pathname.substr(0, hashIndex);\\n  }\\n\\n  var searchIndex = pathname.indexOf('?');\\n  if (searchIndex !== -1) {\\n    search = pathname.substr(searchIndex);\\n    pathname = pathname.substr(0, searchIndex);\\n  }\\n\\n  return {\\n    pathname: pathname,\\n    search: search === '?' ? '' : search,\\n    hash: hash === '#' ? '' : hash\\n  };\\n};\\n\\nexport var createPath = function createPath(location) {\\n  var pathname = location.pathname,\\n      search = location.search,\\n      hash = location.hash;\\n\\n\\n  var path = pathname || '/';\\n\\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\\n\\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\\n\\n  return path;\\n};\",\"var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport resolvePathname from 'resolve-pathname';\\nimport valueEqual from 'value-equal';\\nimport { parsePath } from './PathUtils';\\n\\nexport var createLocation = function createLocation(path, state, key, currentLocation) {\\n  var location = void 0;\\n  if (typeof path === 'string') {\\n    // Two-arg form: push(path, state)\\n    location = parsePath(path);\\n    location.state = state;\\n  } else {\\n    // One-arg form: push(location)\\n    location = _extends({}, path);\\n\\n    if (location.pathname === undefined) location.pathname = '';\\n\\n    if (location.search) {\\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\\n    } else {\\n      location.search = '';\\n    }\\n\\n    if (location.hash) {\\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\\n    } else {\\n      location.hash = '';\\n    }\\n\\n    if (state !== undefined && location.state === undefined) location.state = state;\\n  }\\n\\n  try {\\n    location.pathname = decodeURI(location.pathname);\\n  } catch (e) {\\n    if (e instanceof URIError) {\\n      throw new URIError('Pathname \\\"' + location.pathname + '\\\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\\n    } else {\\n      throw e;\\n    }\\n  }\\n\\n  if (key) location.key = key;\\n\\n  if (currentLocation) {\\n    // Resolve incomplete/relative pathname relative to current location.\\n    if (!location.pathname) {\\n      location.pathname = currentLocation.pathname;\\n    } else if (location.pathname.charAt(0) !== '/') {\\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\\n    }\\n  } else {\\n    // When there is no prior location and pathname is empty, set it to /\\n    if (!location.pathname) {\\n      location.pathname = '/';\\n    }\\n  }\\n\\n  return location;\\n};\\n\\nexport var locationsAreEqual = function locationsAreEqual(a, b) {\\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\\n};\",\"import warning from 'warning';\\n\\nvar createTransitionManager = function createTransitionManager() {\\n  var prompt = null;\\n\\n  var setPrompt = function setPrompt(nextPrompt) {\\n    warning(prompt == null, 'A history supports only one prompt at a time');\\n\\n    prompt = nextPrompt;\\n\\n    return function () {\\n      if (prompt === nextPrompt) prompt = null;\\n    };\\n  };\\n\\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\\n    // TODO: If another transition starts while we're still confirming\\n    // the previous one, we may end up in a weird state. Figure out the\\n    // best way to handle this.\\n    if (prompt != null) {\\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\\n\\n      if (typeof result === 'string') {\\n        if (typeof getUserConfirmation === 'function') {\\n          getUserConfirmation(result, callback);\\n        } else {\\n          warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\\n\\n          callback(true);\\n        }\\n      } else {\\n        // Return false from a transition hook to cancel the transition.\\n        callback(result !== false);\\n      }\\n    } else {\\n      callback(true);\\n    }\\n  };\\n\\n  var listeners = [];\\n\\n  var appendListener = function appendListener(fn) {\\n    var isActive = true;\\n\\n    var listener = function listener() {\\n      if (isActive) fn.apply(undefined, arguments);\\n    };\\n\\n    listeners.push(listener);\\n\\n    return function () {\\n      isActive = false;\\n      listeners = listeners.filter(function (item) {\\n        return item !== listener;\\n      });\\n    };\\n  };\\n\\n  var notifyListeners = function notifyListeners() {\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    listeners.forEach(function (listener) {\\n      return listener.apply(undefined, args);\\n    });\\n  };\\n\\n  return {\\n    setPrompt: setPrompt,\\n    confirmTransitionTo: confirmTransitionTo,\\n    appendListener: appendListener,\\n    notifyListeners: notifyListeners\\n  };\\n};\\n\\nexport default createTransitionManager;\",\"export var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\\n\\nexport var addEventListener = function addEventListener(node, event, listener) {\\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\\n};\\n\\nexport var removeEventListener = function removeEventListener(node, event, listener) {\\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\\n};\\n\\nexport var getConfirmation = function getConfirmation(message, callback) {\\n  return callback(window.confirm(message));\\n}; // eslint-disable-line no-alert\\n\\n/**\\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\\n *\\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\\n */\\nexport var supportsHistory = function supportsHistory() {\\n  var ua = window.navigator.userAgent;\\n\\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\\n\\n  return window.history && 'pushState' in window.history;\\n};\\n\\n/**\\n * Returns true if browser fires popstate on hash change.\\n * IE10 and IE11 do not.\\n */\\nexport var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\\n  return window.navigator.userAgent.indexOf('Trident') === -1;\\n};\\n\\n/**\\n * Returns false if using go(n) with hash history causes a full page reload.\\n */\\nexport var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\\n};\\n\\n/**\\n * Returns true if a given popstate event is an extraneous WebKit event.\\n * Accounts for the fact that Chrome on iOS fires real popstate events\\n * containing undefined state when pressing the back button.\\n */\\nexport var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\\n};\",\"var _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport warning from 'warning';\\nimport invariant from 'invariant';\\nimport { createLocation } from './LocationUtils';\\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\\nimport createTransitionManager from './createTransitionManager';\\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './DOMUtils';\\n\\nvar PopStateEvent = 'popstate';\\nvar HashChangeEvent = 'hashchange';\\n\\nvar getHistoryState = function getHistoryState() {\\n  try {\\n    return window.history.state || {};\\n  } catch (e) {\\n    // IE 11 sometimes throws when accessing window.history.state\\n    // See https://github.com/ReactTraining/history/pull/289\\n    return {};\\n  }\\n};\\n\\n/**\\n * Creates a history object that uses the HTML5 history API including\\n * pushState, replaceState, and the popstate event.\\n */\\nvar createBrowserHistory = function createBrowserHistory() {\\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  invariant(canUseDOM, 'Browser history needs a DOM');\\n\\n  var globalHistory = window.history;\\n  var canUseHistory = supportsHistory();\\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\\n\\n  var _props$forceRefresh = props.forceRefresh,\\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\\n      _props$getUserConfirm = props.getUserConfirmation,\\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\\n      _props$keyLength = props.keyLength,\\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\\n\\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\\n\\n  var getDOMLocation = function getDOMLocation(historyState) {\\n    var _ref = historyState || {},\\n        key = _ref.key,\\n        state = _ref.state;\\n\\n    var _window$location = window.location,\\n        pathname = _window$location.pathname,\\n        search = _window$location.search,\\n        hash = _window$location.hash;\\n\\n\\n    var path = pathname + search + hash;\\n\\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \\\"' + path + '\\\" to begin with \\\"' + basename + '\\\".');\\n\\n    if (basename) path = stripBasename(path, basename);\\n\\n    return createLocation(path, state, key);\\n  };\\n\\n  var createKey = function createKey() {\\n    return Math.random().toString(36).substr(2, keyLength);\\n  };\\n\\n  var transitionManager = createTransitionManager();\\n\\n  var setState = function setState(nextState) {\\n    _extends(history, nextState);\\n\\n    history.length = globalHistory.length;\\n\\n    transitionManager.notifyListeners(history.location, history.action);\\n  };\\n\\n  var handlePopState = function handlePopState(event) {\\n    // Ignore extraneous popstate events in WebKit.\\n    if (isExtraneousPopstateEvent(event)) return;\\n\\n    handlePop(getDOMLocation(event.state));\\n  };\\n\\n  var handleHashChange = function handleHashChange() {\\n    handlePop(getDOMLocation(getHistoryState()));\\n  };\\n\\n  var forceNextPop = false;\\n\\n  var handlePop = function handlePop(location) {\\n    if (forceNextPop) {\\n      forceNextPop = false;\\n      setState();\\n    } else {\\n      var action = 'POP';\\n\\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n        if (ok) {\\n          setState({ action: action, location: location });\\n        } else {\\n          revertPop(location);\\n        }\\n      });\\n    }\\n  };\\n\\n  var revertPop = function revertPop(fromLocation) {\\n    var toLocation = history.location;\\n\\n    // TODO: We could probably make this more reliable by\\n    // keeping a list of keys we've seen in sessionStorage.\\n    // Instead, we just default to 0 for keys we don't know.\\n\\n    var toIndex = allKeys.indexOf(toLocation.key);\\n\\n    if (toIndex === -1) toIndex = 0;\\n\\n    var fromIndex = allKeys.indexOf(fromLocation.key);\\n\\n    if (fromIndex === -1) fromIndex = 0;\\n\\n    var delta = toIndex - fromIndex;\\n\\n    if (delta) {\\n      forceNextPop = true;\\n      go(delta);\\n    }\\n  };\\n\\n  var initialLocation = getDOMLocation(getHistoryState());\\n  var allKeys = [initialLocation.key];\\n\\n  // Public interface\\n\\n  var createHref = function createHref(location) {\\n    return basename + createPath(location);\\n  };\\n\\n  var push = function push(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'PUSH';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var href = createHref(location);\\n      var key = location.key,\\n          state = location.state;\\n\\n\\n      if (canUseHistory) {\\n        globalHistory.pushState({ key: key, state: state }, null, href);\\n\\n        if (forceRefresh) {\\n          window.location.href = href;\\n        } else {\\n          var prevIndex = allKeys.indexOf(history.location.key);\\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\\n\\n          nextKeys.push(location.key);\\n          allKeys = nextKeys;\\n\\n          setState({ action: action, location: location });\\n        }\\n      } else {\\n        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\\n\\n        window.location.href = href;\\n      }\\n    });\\n  };\\n\\n  var replace = function replace(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'REPLACE';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var href = createHref(location);\\n      var key = location.key,\\n          state = location.state;\\n\\n\\n      if (canUseHistory) {\\n        globalHistory.replaceState({ key: key, state: state }, null, href);\\n\\n        if (forceRefresh) {\\n          window.location.replace(href);\\n        } else {\\n          var prevIndex = allKeys.indexOf(history.location.key);\\n\\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\\n\\n          setState({ action: action, location: location });\\n        }\\n      } else {\\n        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\\n\\n        window.location.replace(href);\\n      }\\n    });\\n  };\\n\\n  var go = function go(n) {\\n    globalHistory.go(n);\\n  };\\n\\n  var goBack = function goBack() {\\n    return go(-1);\\n  };\\n\\n  var goForward = function goForward() {\\n    return go(1);\\n  };\\n\\n  var listenerCount = 0;\\n\\n  var checkDOMListeners = function checkDOMListeners(delta) {\\n    listenerCount += delta;\\n\\n    if (listenerCount === 1) {\\n      addEventListener(window, PopStateEvent, handlePopState);\\n\\n      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);\\n    } else if (listenerCount === 0) {\\n      removeEventListener(window, PopStateEvent, handlePopState);\\n\\n      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);\\n    }\\n  };\\n\\n  var isBlocked = false;\\n\\n  var block = function block() {\\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n    var unblock = transitionManager.setPrompt(prompt);\\n\\n    if (!isBlocked) {\\n      checkDOMListeners(1);\\n      isBlocked = true;\\n    }\\n\\n    return function () {\\n      if (isBlocked) {\\n        isBlocked = false;\\n        checkDOMListeners(-1);\\n      }\\n\\n      return unblock();\\n    };\\n  };\\n\\n  var listen = function listen(listener) {\\n    var unlisten = transitionManager.appendListener(listener);\\n    checkDOMListeners(1);\\n\\n    return function () {\\n      checkDOMListeners(-1);\\n      unlisten();\\n    };\\n  };\\n\\n  var history = {\\n    length: globalHistory.length,\\n    action: 'POP',\\n    location: initialLocation,\\n    createHref: createHref,\\n    push: push,\\n    replace: replace,\\n    go: go,\\n    goBack: goBack,\\n    goForward: goForward,\\n    block: block,\\n    listen: listen\\n  };\\n\\n  return history;\\n};\\n\\nexport default createBrowserHistory;\",\"var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport warning from 'warning';\\nimport invariant from 'invariant';\\nimport { createLocation, locationsAreEqual } from './LocationUtils';\\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\\nimport createTransitionManager from './createTransitionManager';\\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\\n\\nvar HashChangeEvent = 'hashchange';\\n\\nvar HashPathCoders = {\\n  hashbang: {\\n    encodePath: function encodePath(path) {\\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\\n    },\\n    decodePath: function decodePath(path) {\\n      return path.charAt(0) === '!' ? path.substr(1) : path;\\n    }\\n  },\\n  noslash: {\\n    encodePath: stripLeadingSlash,\\n    decodePath: addLeadingSlash\\n  },\\n  slash: {\\n    encodePath: addLeadingSlash,\\n    decodePath: addLeadingSlash\\n  }\\n};\\n\\nvar getHashPath = function getHashPath() {\\n  // We can't use window.location.hash here because it's not\\n  // consistent across browsers - Firefox will pre-decode it!\\n  var href = window.location.href;\\n  var hashIndex = href.indexOf('#');\\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\\n};\\n\\nvar pushHashPath = function pushHashPath(path) {\\n  return window.location.hash = path;\\n};\\n\\nvar replaceHashPath = function replaceHashPath(path) {\\n  var hashIndex = window.location.href.indexOf('#');\\n\\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\\n};\\n\\nvar createHashHistory = function createHashHistory() {\\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  invariant(canUseDOM, 'Hash history needs a DOM');\\n\\n  var globalHistory = window.history;\\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\\n\\n  var _props$getUserConfirm = props.getUserConfirmation,\\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\\n      _props$hashType = props.hashType,\\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\\n\\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\\n\\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\\n      encodePath = _HashPathCoders$hashT.encodePath,\\n      decodePath = _HashPathCoders$hashT.decodePath;\\n\\n\\n  var getDOMLocation = function getDOMLocation() {\\n    var path = decodePath(getHashPath());\\n\\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \\\"' + path + '\\\" to begin with \\\"' + basename + '\\\".');\\n\\n    if (basename) path = stripBasename(path, basename);\\n\\n    return createLocation(path);\\n  };\\n\\n  var transitionManager = createTransitionManager();\\n\\n  var setState = function setState(nextState) {\\n    _extends(history, nextState);\\n\\n    history.length = globalHistory.length;\\n\\n    transitionManager.notifyListeners(history.location, history.action);\\n  };\\n\\n  var forceNextPop = false;\\n  var ignorePath = null;\\n\\n  var handleHashChange = function handleHashChange() {\\n    var path = getHashPath();\\n    var encodedPath = encodePath(path);\\n\\n    if (path !== encodedPath) {\\n      // Ensure we always have a properly-encoded hash.\\n      replaceHashPath(encodedPath);\\n    } else {\\n      var location = getDOMLocation();\\n      var prevLocation = history.location;\\n\\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\\n\\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\\n\\n      ignorePath = null;\\n\\n      handlePop(location);\\n    }\\n  };\\n\\n  var handlePop = function handlePop(location) {\\n    if (forceNextPop) {\\n      forceNextPop = false;\\n      setState();\\n    } else {\\n      var action = 'POP';\\n\\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n        if (ok) {\\n          setState({ action: action, location: location });\\n        } else {\\n          revertPop(location);\\n        }\\n      });\\n    }\\n  };\\n\\n  var revertPop = function revertPop(fromLocation) {\\n    var toLocation = history.location;\\n\\n    // TODO: We could probably make this more reliable by\\n    // keeping a list of paths we've seen in sessionStorage.\\n    // Instead, we just default to 0 for paths we don't know.\\n\\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\\n\\n    if (toIndex === -1) toIndex = 0;\\n\\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\\n\\n    if (fromIndex === -1) fromIndex = 0;\\n\\n    var delta = toIndex - fromIndex;\\n\\n    if (delta) {\\n      forceNextPop = true;\\n      go(delta);\\n    }\\n  };\\n\\n  // Ensure the hash is encoded properly before doing anything else.\\n  var path = getHashPath();\\n  var encodedPath = encodePath(path);\\n\\n  if (path !== encodedPath) replaceHashPath(encodedPath);\\n\\n  var initialLocation = getDOMLocation();\\n  var allPaths = [createPath(initialLocation)];\\n\\n  // Public interface\\n\\n  var createHref = function createHref(location) {\\n    return '#' + encodePath(basename + createPath(location));\\n  };\\n\\n  var push = function push(path, state) {\\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\\n\\n    var action = 'PUSH';\\n    var location = createLocation(path, undefined, undefined, history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var path = createPath(location);\\n      var encodedPath = encodePath(basename + path);\\n      var hashChanged = getHashPath() !== encodedPath;\\n\\n      if (hashChanged) {\\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\\n        // rather setState here and ignore the hashchange. The caveat here\\n        // is that other hash histories in the page will consider it a POP.\\n        ignorePath = path;\\n        pushHashPath(encodedPath);\\n\\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\\n\\n        nextPaths.push(path);\\n        allPaths = nextPaths;\\n\\n        setState({ action: action, location: location });\\n      } else {\\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\\n\\n        setState();\\n      }\\n    });\\n  };\\n\\n  var replace = function replace(path, state) {\\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\\n\\n    var action = 'REPLACE';\\n    var location = createLocation(path, undefined, undefined, history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var path = createPath(location);\\n      var encodedPath = encodePath(basename + path);\\n      var hashChanged = getHashPath() !== encodedPath;\\n\\n      if (hashChanged) {\\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\\n        // rather setState here and ignore the hashchange. The caveat here\\n        // is that other hash histories in the page will consider it a POP.\\n        ignorePath = path;\\n        replaceHashPath(encodedPath);\\n      }\\n\\n      var prevIndex = allPaths.indexOf(createPath(history.location));\\n\\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\\n\\n      setState({ action: action, location: location });\\n    });\\n  };\\n\\n  var go = function go(n) {\\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\\n\\n    globalHistory.go(n);\\n  };\\n\\n  var goBack = function goBack() {\\n    return go(-1);\\n  };\\n\\n  var goForward = function goForward() {\\n    return go(1);\\n  };\\n\\n  var listenerCount = 0;\\n\\n  var checkDOMListeners = function checkDOMListeners(delta) {\\n    listenerCount += delta;\\n\\n    if (listenerCount === 1) {\\n      addEventListener(window, HashChangeEvent, handleHashChange);\\n    } else if (listenerCount === 0) {\\n      removeEventListener(window, HashChangeEvent, handleHashChange);\\n    }\\n  };\\n\\n  var isBlocked = false;\\n\\n  var block = function block() {\\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n    var unblock = transitionManager.setPrompt(prompt);\\n\\n    if (!isBlocked) {\\n      checkDOMListeners(1);\\n      isBlocked = true;\\n    }\\n\\n    return function () {\\n      if (isBlocked) {\\n        isBlocked = false;\\n        checkDOMListeners(-1);\\n      }\\n\\n      return unblock();\\n    };\\n  };\\n\\n  var listen = function listen(listener) {\\n    var unlisten = transitionManager.appendListener(listener);\\n    checkDOMListeners(1);\\n\\n    return function () {\\n      checkDOMListeners(-1);\\n      unlisten();\\n    };\\n  };\\n\\n  var history = {\\n    length: globalHistory.length,\\n    action: 'POP',\\n    location: initialLocation,\\n    createHref: createHref,\\n    push: push,\\n    replace: replace,\\n    go: go,\\n    goBack: goBack,\\n    goForward: goForward,\\n    block: block,\\n    listen: listen\\n  };\\n\\n  return history;\\n};\\n\\nexport default createHashHistory;\",\"var _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport warning from 'warning';\\nimport { createPath } from './PathUtils';\\nimport { createLocation } from './LocationUtils';\\nimport createTransitionManager from './createTransitionManager';\\n\\nvar clamp = function clamp(n, lowerBound, upperBound) {\\n  return Math.min(Math.max(n, lowerBound), upperBound);\\n};\\n\\n/**\\n * Creates a history object that stores locations in memory.\\n */\\nvar createMemoryHistory = function createMemoryHistory() {\\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var getUserConfirmation = props.getUserConfirmation,\\n      _props$initialEntries = props.initialEntries,\\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\\n      _props$initialIndex = props.initialIndex,\\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\\n      _props$keyLength = props.keyLength,\\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\\n\\n\\n  var transitionManager = createTransitionManager();\\n\\n  var setState = function setState(nextState) {\\n    _extends(history, nextState);\\n\\n    history.length = history.entries.length;\\n\\n    transitionManager.notifyListeners(history.location, history.action);\\n  };\\n\\n  var createKey = function createKey() {\\n    return Math.random().toString(36).substr(2, keyLength);\\n  };\\n\\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\\n  var entries = initialEntries.map(function (entry) {\\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\\n  });\\n\\n  // Public interface\\n\\n  var createHref = createPath;\\n\\n  var push = function push(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'PUSH';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var prevIndex = history.index;\\n      var nextIndex = prevIndex + 1;\\n\\n      var nextEntries = history.entries.slice(0);\\n      if (nextEntries.length > nextIndex) {\\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\\n      } else {\\n        nextEntries.push(location);\\n      }\\n\\n      setState({\\n        action: action,\\n        location: location,\\n        index: nextIndex,\\n        entries: nextEntries\\n      });\\n    });\\n  };\\n\\n  var replace = function replace(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'REPLACE';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      history.entries[history.index] = location;\\n\\n      setState({ action: action, location: location });\\n    });\\n  };\\n\\n  var go = function go(n) {\\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\\n\\n    var action = 'POP';\\n    var location = history.entries[nextIndex];\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (ok) {\\n        setState({\\n          action: action,\\n          location: location,\\n          index: nextIndex\\n        });\\n      } else {\\n        // Mimic the behavior of DOM histories by\\n        // causing a render after a cancelled POP.\\n        setState();\\n      }\\n    });\\n  };\\n\\n  var goBack = function goBack() {\\n    return go(-1);\\n  };\\n\\n  var goForward = function goForward() {\\n    return go(1);\\n  };\\n\\n  var canGo = function canGo(n) {\\n    var nextIndex = history.index + n;\\n    return nextIndex >= 0 && nextIndex < history.entries.length;\\n  };\\n\\n  var block = function block() {\\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n    return transitionManager.setPrompt(prompt);\\n  };\\n\\n  var listen = function listen(listener) {\\n    return transitionManager.appendListener(listener);\\n  };\\n\\n  var history = {\\n    length: entries.length,\\n    action: 'POP',\\n    location: entries[index],\\n    index: index,\\n    entries: entries,\\n    createHref: createHref,\\n    push: push,\\n    replace: replace,\\n    go: go,\\n    goBack: goBack,\\n    goForward: goForward,\\n    canGo: canGo,\\n    block: block,\\n    listen: listen\\n  };\\n\\n  return history;\\n};\\n\\nexport default createMemoryHistory;\",\"import _createBrowserHistory from './createBrowserHistory';\\nexport { _createBrowserHistory as createBrowserHistory };\\nimport _createHashHistory from './createHashHistory';\\nexport { _createHashHistory as createHashHistory };\\nimport _createMemoryHistory from './createMemoryHistory';\\nexport { _createMemoryHistory as createMemoryHistory };\\n\\nexport { createLocation, locationsAreEqual } from './LocationUtils';\\nexport { parsePath, createPath } from './PathUtils';\",\"/**\\n * Copyright 2014-2015, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n */\\n\\n'use strict';\\n\\n/**\\n * Similar to invariant but only logs a warning if the condition is not met.\\n * This can be used to log issues in development environments in critical\\n * paths. Removing the logging code for production environments will keep the\\n * same logic and follow the same code paths.\\n */\\n\\nvar warning = function() {};\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  warning = function(condition, format, args) {\\n    var len = arguments.length;\\n    args = new Array(len > 2 ? len - 2 : 0);\\n    for (var key = 2; key < len; key++) {\\n      args[key - 2] = arguments[key];\\n    }\\n    if (format === undefined) {\\n      throw new Error(\\n        '`warning(condition, format, ...args)` requires a warning ' +\\n        'message argument'\\n      );\\n    }\\n\\n    if (format.length < 10 || (/^[s\\\\W]*$/).test(format)) {\\n      throw new Error(\\n        'The warning format should be able to uniquely identify this ' +\\n        'warning. Please, use a more descriptive format than: ' + format\\n      );\\n    }\\n\\n    if (!condition) {\\n      var argIndex = 0;\\n      var message = 'Warning: ' +\\n        format.replace(/%s/g, function() {\\n          return args[argIndex++];\\n        });\\n      if (typeof console !== 'undefined') {\\n        console.error(message);\\n      }\\n      try {\\n        // This error was thrown as a convenience so that you can use this stack\\n        // to find the callsite that caused this warning to fire.\\n        throw new Error(message);\\n      } catch(x) {}\\n    }\\n  };\\n}\\n\\nmodule.exports = warning;\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{YHGo:function(n,t,e){\"use strict\";var o=e(\"g8bd\"),r=e.n(o),a=e(\"QLaP\"),i=e.n(a),s=e(\"Rh1G\"),c=e(\"w6Ft\"),u=function(n){return\"/\"===n.charAt(0)?n:\"/\"+n},h=function(n,t){return new RegExp(\"^\"+t+\"(\\\\/|\\\\?|#|$)\",\"i\").test(n)},f=function(n,t){return h(n,t)?n.substr(t.length):n},d=function(n){return\"/\"===n.charAt(n.length-1)?n.slice(0,-1):n},p=function(n){var t=n.pathname,e=n.search,o=n.hash,r=t||\"/\";return e&&\"?\"!==e&&(r+=\"?\"===e.charAt(0)?e:\"?\"+e),o&&\"#\"!==o&&(r+=\"#\"===o.charAt(0)?o:\"#\"+o),r},l=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o])}return n},v=function(n,t,e,o){var r=void 0;\"string\"==typeof n?(r=function(n){var t=n||\"/\",e=\"\",o=\"\",r=t.indexOf(\"#\");-1!==r&&(o=t.substr(r),t=t.substr(0,r));var a=t.indexOf(\"?\");return-1!==a&&(e=t.substr(a),t=t.substr(0,a)),{pathname:t,search:\"?\"===e?\"\":e,hash:\"#\"===o?\"\":o}}(n)).state=t:(void 0===(r=l({},n)).pathname&&(r.pathname=\"\"),r.search?\"?\"!==r.search.charAt(0)&&(r.search=\"?\"+r.search):r.search=\"\",r.hash?\"#\"!==r.hash.charAt(0)&&(r.hash=\"#\"+r.hash):r.hash=\"\",void 0!==t&&void 0===r.state&&(r.state=t));try{r.pathname=decodeURI(r.pathname)}catch(n){throw n instanceof URIError?new URIError('Pathname \"'+r.pathname+'\" could not be decoded. This is likely caused by an invalid percent-encoding.'):n}return e&&(r.key=e),o?r.pathname?\"/\"!==r.pathname.charAt(0)&&(r.pathname=Object(s.a)(r.pathname,o.pathname)):r.pathname=o.pathname:r.pathname||(r.pathname=\"/\"),r},y=function(n,t){return n.pathname===t.pathname&&n.search===t.search&&n.hash===t.hash&&n.key===t.key&&Object(c.a)(n.state,t.state)},w=function(){var n=null,t=[];return{setPrompt:function(t){return r()(null==n,\"A history supports only one prompt at a time\"),n=t,function(){n===t&&(n=null)}},confirmTransitionTo:function(t,e,o,a){if(null!=n){var i=\"function\"==typeof n?n(t,e):n;\"string\"==typeof i?\"function\"==typeof o?o(i,a):(r()(!1,\"A history needs a getUserConfirmation function in order to use a prompt message\"),a(!0)):a(!1!==i)}else a(!0)},appendListener:function(n){var e=!0,o=function(){e&&n.apply(void 0,arguments)};return t.push(o),function(){e=!1,t=t.filter(function(n){return n!==o})}},notifyListeners:function(){for(var n=arguments.length,e=Array(n),o=0;o<n;o++)e[o]=arguments[o];t.forEach(function(n){return n.apply(void 0,e)})}}},m=!(\"undefined\"==typeof window||!window.document||!window.document.createElement),g=function(n,t,e){return n.addEventListener?n.addEventListener(t,e,!1):n.attachEvent(\"on\"+t,e)},b=function(n,t,e){return n.removeEventListener?n.removeEventListener(t,e,!1):n.detachEvent(\"on\"+t,e)},O=function(n,t){return t(window.confirm(n))},k=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&\"function\"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?\"symbol\":typeof n},A=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o])}return n},P=function(){try{return window.history.state||{}}catch(n){return{}}},x=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i()(m,\"Browser history needs a DOM\");var t,e=window.history,o=(-1===(t=window.navigator.userAgent).indexOf(\"Android 2.\")&&-1===t.indexOf(\"Android 4.0\")||-1===t.indexOf(\"Mobile Safari\")||-1!==t.indexOf(\"Chrome\")||-1!==t.indexOf(\"Windows Phone\"))&&window.history&&\"pushState\"in window.history,a=!(-1===window.navigator.userAgent.indexOf(\"Trident\")),s=n.forceRefresh,c=void 0!==s&&s,l=n.getUserConfirmation,y=void 0===l?O:l,x=n.keyLength,E=void 0===x?6:x,L=n.basename?d(u(n.basename)):\"\",S=function(n){var t=n||{},e=t.key,o=t.state,a=window.location,i=a.pathname+a.search+a.hash;return r()(!L||h(i,L),'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path \"'+i+'\" to begin with \"'+L+'\".'),L&&(i=f(i,L)),v(i,o,e)},j=function(){return Math.random().toString(36).substr(2,E)},T=w(),R=function(n){A(W,n),W.length=e.length,T.notifyListeners(W.location,W.action)},U=function(n){(function(n){return void 0===n.state&&-1===navigator.userAgent.indexOf(\"CriOS\")})(n)||M(S(n.state))},C=function(){M(S(P()))},H=!1,M=function(n){H?(H=!1,R()):T.confirmTransitionTo(n,\"POP\",y,function(t){t?R({action:\"POP\",location:n}):B(n)})},B=function(n){var t=W.location,e=I.indexOf(t.key);-1===e&&(e=0);var o=I.indexOf(n.key);-1===o&&(o=0);var r=e-o;r&&(H=!0,G(r))},Y=S(P()),I=[Y.key],F=function(n){return L+p(n)},G=function(n){e.go(n)},J=0,D=function(n){1===(J+=n)?(g(window,\"popstate\",U),a&&g(window,\"hashchange\",C)):0===J&&(b(window,\"popstate\",U),a&&b(window,\"hashchange\",C))},Q=!1,W={length:e.length,action:\"POP\",location:Y,createHref:F,push:function(n,t){r()(!(\"object\"===(void 0===n?\"undefined\":k(n))&&void 0!==n.state&&void 0!==t),\"You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored\");var a=v(n,t,j(),W.location);T.confirmTransitionTo(a,\"PUSH\",y,function(n){if(n){var t=F(a),i=a.key,s=a.state;if(o)if(e.pushState({key:i,state:s},null,t),c)window.location.href=t;else{var u=I.indexOf(W.location.key),h=I.slice(0,-1===u?0:u+1);h.push(a.key),I=h,R({action:\"PUSH\",location:a})}else r()(void 0===s,\"Browser history cannot push state in browsers that do not support HTML5 history\"),window.location.href=t}})},replace:function(n,t){r()(!(\"object\"===(void 0===n?\"undefined\":k(n))&&void 0!==n.state&&void 0!==t),\"You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored\");var a=v(n,t,j(),W.location);T.confirmTransitionTo(a,\"REPLACE\",y,function(n){if(n){var t=F(a),i=a.key,s=a.state;if(o)if(e.replaceState({key:i,state:s},null,t),c)window.location.replace(t);else{var u=I.indexOf(W.location.key);-1!==u&&(I[u]=a.key),R({action:\"REPLACE\",location:a})}else r()(void 0===s,\"Browser history cannot replace state in browsers that do not support HTML5 history\"),window.location.replace(t)}})},go:G,goBack:function(){return G(-1)},goForward:function(){return G(1)},block:function(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=T.setPrompt(n);return Q||(D(1),Q=!0),function(){return Q&&(Q=!1,D(-1)),t()}},listen:function(n){var t=T.appendListener(n);return D(1),function(){D(-1),t()}}};return W};Object.assign,\"function\"==typeof Symbol&&Symbol.iterator,Object.assign;e.d(t,\"a\",function(){return x}),e.d(t,\"b\",function(){return v}),e.d(t,\"c\",function(){return y})},g8bd:function(n,t,e){\"use strict\";n.exports=function(){}}}]);","extractedComments":[]}