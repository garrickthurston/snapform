{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\evp_bytestokey\\\\index.js\"],\"names\":[\"Buffer\",\"__webpack_require__\",\"MD5\",\"module\",\"exports\",\"password\",\"salt\",\"keyBits\",\"ivLen\",\"isBuffer\",\"from\",\"length\",\"RangeError\",\"keyLen\",\"key\",\"alloc\",\"iv\",\"tmp\",\"hash\",\"update\",\"digest\",\"used\",\"keyStart\",\"Math\",\"min\",\"copy\",\"ivStart\",\"fill\"],\"mappings\":\"+EAAA,IAAAA,EAAaC,EAAQ,QAAaD,OAClCE,EAAUD,EAAQ,QA2ClBE,EAAAC,QAxCA,SAAAC,EAAAC,EAAAC,EAAAC,GAEA,GADAR,EAAAS,SAAAJ,KAAAA,EAAAL,EAAAU,KAAAL,EAAA,WACAC,IACAN,EAAAS,SAAAH,KAAAA,EAAAN,EAAAU,KAAAJ,EAAA,WACA,IAAAA,EAAAK,QAAA,MAAA,IAAAC,WAAA,4CAQA,IALA,IAAAC,EAAAN,EAAA,EACAO,EAAAd,EAAAe,MAAAF,GACAG,EAAAhB,EAAAe,MAAAP,GAAA,GACAS,EAAAjB,EAAAe,MAAA,GAEAF,EAAA,GAAAL,EAAA,GAAA,CACA,IAAAU,EAAA,IAAAhB,EACAgB,EAAAC,OAAAF,GACAC,EAAAC,OAAAd,GACAC,GAAAY,EAAAC,OAAAb,GACAW,EAAAC,EAAAE,SAEA,IAAAC,EAAA,EAEA,GAAAR,EAAA,EAAA,CACA,IAAAS,EAAAR,EAAAH,OAAAE,EACAQ,EAAAE,KAAAC,IAAAX,EAAAI,EAAAN,QACAM,EAAAQ,KAAAX,EAAAQ,EAAA,EAAAD,GACAR,GAAAQ,EAGA,GAAAA,EAAAJ,EAAAN,QAAAH,EAAA,EAAA,CACA,IAAAkB,EAAAV,EAAAL,OAAAH,EACAG,EAAAY,KAAAC,IAAAhB,EAAAS,EAAAN,OAAAU,GACAJ,EAAAQ,KAAAT,EAAAU,EAAAL,EAAAA,EAAAV,GACAH,GAAAG,GAKA,OADAM,EAAAU,KAAA,GACA,CAAUb,IAAAA,EAAAE,GAAAA\",\"sourcesContent\":[\"var Buffer = require('safe-buffer').Buffer\\nvar MD5 = require('md5.js')\\n\\n/* eslint-disable camelcase */\\nfunction EVP_BytesToKey (password, salt, keyBits, ivLen) {\\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')\\n  if (salt) {\\n    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')\\n    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')\\n  }\\n\\n  var keyLen = keyBits / 8\\n  var key = Buffer.alloc(keyLen)\\n  var iv = Buffer.alloc(ivLen || 0)\\n  var tmp = Buffer.alloc(0)\\n\\n  while (keyLen > 0 || ivLen > 0) {\\n    var hash = new MD5()\\n    hash.update(tmp)\\n    hash.update(password)\\n    if (salt) hash.update(salt)\\n    tmp = hash.digest()\\n\\n    var used = 0\\n\\n    if (keyLen > 0) {\\n      var keyStart = key.length - keyLen\\n      used = Math.min(keyLen, tmp.length)\\n      tmp.copy(key, keyStart, 0, used)\\n      keyLen -= used\\n    }\\n\\n    if (used < tmp.length && ivLen > 0) {\\n      var ivStart = iv.length - ivLen\\n      var length = Math.min(ivLen, tmp.length - used)\\n      tmp.copy(iv, ivStart, used, used + length)\\n      ivLen -= length\\n    }\\n  }\\n\\n  tmp.fill(0)\\n  return { key: key, iv: iv }\\n}\\n\\nmodule.exports = EVP_BytesToKey\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{roQf:function(e,n,r){var t=r(\"hwdV\").Buffer,a=r(\"9XZ3\");e.exports=function(e,n,r,o){if(t.isBuffer(e)||(e=t.from(e,\"binary\")),n&&(t.isBuffer(n)||(n=t.from(n,\"binary\")),8!==n.length))throw new RangeError(\"salt should be Buffer with 8 byte length\");for(var f=r/8,i=t.alloc(f),l=t.alloc(o||0),h=t.alloc(0);f>0||o>0;){var u=new a;u.update(h),u.update(e),n&&u.update(n),h=u.digest();var p=0;if(f>0){var w=i.length-f;p=Math.min(f,h.length),h.copy(i,w,0,p),f-=p}if(p<h.length&&o>0){var c=l.length-o,g=Math.min(o,h.length-p);h.copy(l,c,p,p+g),o-=g}}return h.fill(0),{key:i,iv:l}}}}]);","extractedComments":[]}