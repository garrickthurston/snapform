{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\cipher-base\\\\index.js\"],\"names\":[\"Buffer\",\"__webpack_require__\",\"Transform\",\"StringDecoder\",\"CipherBase\",\"hashMode\",\"call\",\"this\",\"_finalOrDigest\",\"final\",\"_final\",\"__final\",\"_decoder\",\"_encoding\",\"inherits\",\"prototype\",\"update\",\"data\",\"inputEnc\",\"outputEnc\",\"from\",\"outData\",\"_update\",\"_toString\",\"setAutoPadding\",\"getAuthTag\",\"Error\",\"setAuthTag\",\"setAAD\",\"_transform\",\"_\",\"next\",\"err\",\"push\",\"e\",\"_flush\",\"done\",\"alloc\",\"value\",\"enc\",\"fin\",\"out\",\"write\",\"end\",\"module\",\"exports\"],\"mappings\":\"+EAAA,IAAAA,EAAaC,EAAQ,QAAaD,OAClCE,EAAgBD,EAAQ,QAAQC,UAChCC,EAAoBF,EAAQ,QAAgBE,cAG5C,SAAAC,EAAAC,GACAH,EAAAI,KAAAC,MACAA,KAAAF,SAAA,iBAAAA,EACAE,KAAAF,SACAE,KAAAF,GAAAE,KAAAC,eAEAD,KAAAE,MAAAF,KAAAC,eAEAD,KAAAG,SACAH,KAAAI,QAAAJ,KAAAG,OACAH,KAAAG,OAAA,MAEAH,KAAAK,SAAA,KACAL,KAAAM,UAAA,KAfeZ,EAAQ,OAiBvBa,CAAAV,EAAAF,GAEAE,EAAAW,UAAAC,OAAA,SAAAC,EAAAC,EAAAC,GACA,iBAAAF,IACAA,EAAAjB,EAAAoB,KAAAH,EAAAC,IAGA,IAAAG,EAAAd,KAAAe,QAAAL,GACA,OAAAV,KAAAF,SAAAE,MAEAY,IACAE,EAAAd,KAAAgB,UAAAF,EAAAF,IAGAE,IAGAjB,EAAAW,UAAAS,eAAA,aACApB,EAAAW,UAAAU,WAAA,WACA,MAAA,IAAAC,MAAA,gDAGAtB,EAAAW,UAAAY,WAAA,WACA,MAAA,IAAAD,MAAA,gDAGAtB,EAAAW,UAAAa,OAAA,WACA,MAAA,IAAAF,MAAA,2CAGAtB,EAAAW,UAAAc,WAAA,SAAAZ,EAAAa,EAAAC,GACA,IAAAC,EACA,IACAzB,KAAAF,SACAE,KAAAe,QAAAL,GAEAV,KAAA0B,KAAA1B,KAAAe,QAAAL,IAEG,MAAAiB,GACHF,EAAAE,EACG,QACHH,EAAAC,KAGA5B,EAAAW,UAAAoB,OAAA,SAAAC,GACA,IAAAJ,EACA,IACAzB,KAAA0B,KAAA1B,KAAAI,WACG,MAAAuB,GACHF,EAAAE,EAGAE,EAAAJ,IAEA5B,EAAAW,UAAAP,eAAA,SAAAW,GACA,IAAAE,EAAAd,KAAAI,WAAAX,EAAAqC,MAAA,GAIA,OAHAlB,IACAE,EAAAd,KAAAgB,UAAAF,EAAAF,GAAA,IAEAE,GAGAjB,EAAAW,UAAAQ,UAAA,SAAAe,EAAAC,EAAAC,GAMA,GALAjC,KAAAK,WACAL,KAAAK,SAAA,IAAAT,EAAAoC,GACAhC,KAAAM,UAAA0B,GAGAhC,KAAAM,YAAA0B,EAAA,MAAA,IAAAb,MAAA,0BAEA,IAAAe,EAAAlC,KAAAK,SAAA8B,MAAAJ,GAKA,OAJAE,IACAC,GAAAlC,KAAAK,SAAA+B,OAGAF,GAGAG,EAAAC,QAAAzC\",\"sourcesContent\":[\"var Buffer = require('safe-buffer').Buffer\\nvar Transform = require('stream').Transform\\nvar StringDecoder = require('string_decoder').StringDecoder\\nvar inherits = require('inherits')\\n\\nfunction CipherBase (hashMode) {\\n  Transform.call(this)\\n  this.hashMode = typeof hashMode === 'string'\\n  if (this.hashMode) {\\n    this[hashMode] = this._finalOrDigest\\n  } else {\\n    this.final = this._finalOrDigest\\n  }\\n  if (this._final) {\\n    this.__final = this._final\\n    this._final = null\\n  }\\n  this._decoder = null\\n  this._encoding = null\\n}\\ninherits(CipherBase, Transform)\\n\\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\\n  if (typeof data === 'string') {\\n    data = Buffer.from(data, inputEnc)\\n  }\\n\\n  var outData = this._update(data)\\n  if (this.hashMode) return this\\n\\n  if (outputEnc) {\\n    outData = this._toString(outData, outputEnc)\\n  }\\n\\n  return outData\\n}\\n\\nCipherBase.prototype.setAutoPadding = function () {}\\nCipherBase.prototype.getAuthTag = function () {\\n  throw new Error('trying to get auth tag in unsupported state')\\n}\\n\\nCipherBase.prototype.setAuthTag = function () {\\n  throw new Error('trying to set auth tag in unsupported state')\\n}\\n\\nCipherBase.prototype.setAAD = function () {\\n  throw new Error('trying to set aad in unsupported state')\\n}\\n\\nCipherBase.prototype._transform = function (data, _, next) {\\n  var err\\n  try {\\n    if (this.hashMode) {\\n      this._update(data)\\n    } else {\\n      this.push(this._update(data))\\n    }\\n  } catch (e) {\\n    err = e\\n  } finally {\\n    next(err)\\n  }\\n}\\nCipherBase.prototype._flush = function (done) {\\n  var err\\n  try {\\n    this.push(this.__final())\\n  } catch (e) {\\n    err = e\\n  }\\n\\n  done(err)\\n}\\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\\n  var outData = this.__final() || Buffer.alloc(0)\\n  if (outputEnc) {\\n    outData = this._toString(outData, outputEnc, true)\\n  }\\n  return outData\\n}\\n\\nCipherBase.prototype._toString = function (value, enc, fin) {\\n  if (!this._decoder) {\\n    this._decoder = new StringDecoder(enc)\\n    this._encoding = enc\\n  }\\n\\n  if (this._encoding !== enc) throw new Error('can\\\\'t switch encodings')\\n\\n  var out = this._decoder.write(value)\\n  if (fin) {\\n    out += this._decoder.end()\\n  }\\n\\n  return out\\n}\\n\\nmodule.exports = CipherBase\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{ZDAU:function(t,i,n){var o=n(\"hwdV\").Buffer,r=n(\"1IWx\").Transform,e=n(\"fXKp\").StringDecoder;function s(t){r.call(this),this.hashMode=\"string\"==typeof t,this.hashMode?this[t]=this._finalOrDigest:this.final=this._finalOrDigest,this._final&&(this.__final=this._final,this._final=null),this._decoder=null,this._encoding=null}n(\"P7XM\")(s,r),s.prototype.update=function(t,i,n){\"string\"==typeof t&&(t=o.from(t,i));var r=this._update(t);return this.hashMode?this:(n&&(r=this._toString(r,n)),r)},s.prototype.setAutoPadding=function(){},s.prototype.getAuthTag=function(){throw new Error(\"trying to get auth tag in unsupported state\")},s.prototype.setAuthTag=function(){throw new Error(\"trying to set auth tag in unsupported state\")},s.prototype.setAAD=function(){throw new Error(\"trying to set aad in unsupported state\")},s.prototype._transform=function(t,i,n){var o;try{this.hashMode?this._update(t):this.push(this._update(t))}catch(t){o=t}finally{n(o)}},s.prototype._flush=function(t){var i;try{this.push(this.__final())}catch(t){i=t}t(i)},s.prototype._finalOrDigest=function(t){var i=this.__final()||o.alloc(0);return t&&(i=this._toString(i,t,!0)),i},s.prototype._toString=function(t,i,n){if(this._decoder||(this._decoder=new e(i),this._encoding=i),this._encoding!==i)throw new Error(\"can't switch encodings\");var o=this._decoder.write(t);return n&&(o+=this._decoder.end()),o},t.exports=s}}]);","extractedComments":[]}