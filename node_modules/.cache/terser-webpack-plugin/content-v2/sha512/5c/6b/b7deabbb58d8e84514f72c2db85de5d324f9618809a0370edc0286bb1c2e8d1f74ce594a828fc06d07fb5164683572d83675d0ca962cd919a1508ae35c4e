{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\string_decoder\\\\lib\\\\string_decoder.js\"],\"names\":[\"Buffer\",\"__webpack_require__\",\"isEncoding\",\"encoding\",\"toLowerCase\",\"StringDecoder\",\"nb\",\"this\",\"enc\",\"nenc\",\"retried\",\"_normalizeEncoding\",\"Error\",\"normalizeEncoding\",\"text\",\"utf16Text\",\"end\",\"utf16End\",\"fillLast\",\"utf8FillLast\",\"base64Text\",\"base64End\",\"write\",\"simpleWrite\",\"simpleEnd\",\"lastNeed\",\"lastTotal\",\"lastChar\",\"allocUnsafe\",\"utf8CheckByte\",\"byte\",\"buf\",\"p\",\"r\",\"self\",\"length\",\"utf8CheckExtraBytes\",\"undefined\",\"copy\",\"toString\",\"i\",\"c\",\"charCodeAt\",\"slice\",\"n\",\"exports\",\"prototype\",\"total\",\"j\",\"utf8CheckIncomplete\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\n/*<replacement>*/\\n\\nvar Buffer = require('safe-buffer').Buffer;\\n/*</replacement>*/\\n\\nvar isEncoding = Buffer.isEncoding || function (encoding) {\\n  encoding = '' + encoding;\\n  switch (encoding && encoding.toLowerCase()) {\\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\\n      return true;\\n    default:\\n      return false;\\n  }\\n};\\n\\nfunction _normalizeEncoding(enc) {\\n  if (!enc) return 'utf8';\\n  var retried;\\n  while (true) {\\n    switch (enc) {\\n      case 'utf8':\\n      case 'utf-8':\\n        return 'utf8';\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return 'utf16le';\\n      case 'latin1':\\n      case 'binary':\\n        return 'latin1';\\n      case 'base64':\\n      case 'ascii':\\n      case 'hex':\\n        return enc;\\n      default:\\n        if (retried) return; // undefined\\n        enc = ('' + enc).toLowerCase();\\n        retried = true;\\n    }\\n  }\\n};\\n\\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\\n// modules monkey-patch it to support additional encodings\\nfunction normalizeEncoding(enc) {\\n  var nenc = _normalizeEncoding(enc);\\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\\n  return nenc || enc;\\n}\\n\\n// StringDecoder provides an interface for efficiently splitting a series of\\n// buffers into a series of JS strings without breaking apart multi-byte\\n// characters.\\nexports.StringDecoder = StringDecoder;\\nfunction StringDecoder(encoding) {\\n  this.encoding = normalizeEncoding(encoding);\\n  var nb;\\n  switch (this.encoding) {\\n    case 'utf16le':\\n      this.text = utf16Text;\\n      this.end = utf16End;\\n      nb = 4;\\n      break;\\n    case 'utf8':\\n      this.fillLast = utf8FillLast;\\n      nb = 4;\\n      break;\\n    case 'base64':\\n      this.text = base64Text;\\n      this.end = base64End;\\n      nb = 3;\\n      break;\\n    default:\\n      this.write = simpleWrite;\\n      this.end = simpleEnd;\\n      return;\\n  }\\n  this.lastNeed = 0;\\n  this.lastTotal = 0;\\n  this.lastChar = Buffer.allocUnsafe(nb);\\n}\\n\\nStringDecoder.prototype.write = function (buf) {\\n  if (buf.length === 0) return '';\\n  var r;\\n  var i;\\n  if (this.lastNeed) {\\n    r = this.fillLast(buf);\\n    if (r === undefined) return '';\\n    i = this.lastNeed;\\n    this.lastNeed = 0;\\n  } else {\\n    i = 0;\\n  }\\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\\n  return r || '';\\n};\\n\\nStringDecoder.prototype.end = utf8End;\\n\\n// Returns only complete characters in a Buffer\\nStringDecoder.prototype.text = utf8Text;\\n\\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\\nStringDecoder.prototype.fillLast = function (buf) {\\n  if (this.lastNeed <= buf.length) {\\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\\n  }\\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\\n  this.lastNeed -= buf.length;\\n};\\n\\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\\n// continuation byte. If an invalid byte is detected, -2 is returned.\\nfunction utf8CheckByte(byte) {\\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\\n  return byte >> 6 === 0x02 ? -1 : -2;\\n}\\n\\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\\n// needed to complete the UTF-8 character (if applicable) are returned.\\nfunction utf8CheckIncomplete(self, buf, i) {\\n  var j = buf.length - 1;\\n  if (j < i) return 0;\\n  var nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) self.lastNeed = nb - 1;\\n    return nb;\\n  }\\n  if (--j < i || nb === -2) return 0;\\n  nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) self.lastNeed = nb - 2;\\n    return nb;\\n  }\\n  if (--j < i || nb === -2) return 0;\\n  nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) {\\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\\n    }\\n    return nb;\\n  }\\n  return 0;\\n}\\n\\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\\n// needed or are available. If we see a non-continuation byte where we expect\\n// one, we \\\"replace\\\" the validated continuation bytes we've seen so far with\\n// a single UTF-8 replacement character ('\\\\ufffd'), to match v8's UTF-8 decoding\\n// behavior. The continuation byte check is included three times in the case\\n// where all of the continuation bytes for a character exist in the same buffer.\\n// It is also done this way as a slight performance increase instead of using a\\n// loop.\\nfunction utf8CheckExtraBytes(self, buf, p) {\\n  if ((buf[0] & 0xC0) !== 0x80) {\\n    self.lastNeed = 0;\\n    return '\\\\ufffd';\\n  }\\n  if (self.lastNeed > 1 && buf.length > 1) {\\n    if ((buf[1] & 0xC0) !== 0x80) {\\n      self.lastNeed = 1;\\n      return '\\\\ufffd';\\n    }\\n    if (self.lastNeed > 2 && buf.length > 2) {\\n      if ((buf[2] & 0xC0) !== 0x80) {\\n        self.lastNeed = 2;\\n        return '\\\\ufffd';\\n      }\\n    }\\n  }\\n}\\n\\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\\nfunction utf8FillLast(buf) {\\n  var p = this.lastTotal - this.lastNeed;\\n  var r = utf8CheckExtraBytes(this, buf, p);\\n  if (r !== undefined) return r;\\n  if (this.lastNeed <= buf.length) {\\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\\n  }\\n  buf.copy(this.lastChar, p, 0, buf.length);\\n  this.lastNeed -= buf.length;\\n}\\n\\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\\n// partial character, the character's bytes are buffered until the required\\n// number of bytes are available.\\nfunction utf8Text(buf, i) {\\n  var total = utf8CheckIncomplete(this, buf, i);\\n  if (!this.lastNeed) return buf.toString('utf8', i);\\n  this.lastTotal = total;\\n  var end = buf.length - (total - this.lastNeed);\\n  buf.copy(this.lastChar, 0, end);\\n  return buf.toString('utf8', i, end);\\n}\\n\\n// For UTF-8, a replacement character is added when ending on a partial\\n// character.\\nfunction utf8End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) return r + '\\\\ufffd';\\n  return r;\\n}\\n\\n// UTF-16LE typically needs two bytes per character, but even if we have an even\\n// number of bytes available, we need to check if we end on a leading/high\\n// surrogate. In that case, we need to wait for the next two bytes in order to\\n// decode the last character properly.\\nfunction utf16Text(buf, i) {\\n  if ((buf.length - i) % 2 === 0) {\\n    var r = buf.toString('utf16le', i);\\n    if (r) {\\n      var c = r.charCodeAt(r.length - 1);\\n      if (c >= 0xD800 && c <= 0xDBFF) {\\n        this.lastNeed = 2;\\n        this.lastTotal = 4;\\n        this.lastChar[0] = buf[buf.length - 2];\\n        this.lastChar[1] = buf[buf.length - 1];\\n        return r.slice(0, -1);\\n      }\\n    }\\n    return r;\\n  }\\n  this.lastNeed = 1;\\n  this.lastTotal = 2;\\n  this.lastChar[0] = buf[buf.length - 1];\\n  return buf.toString('utf16le', i, buf.length - 1);\\n}\\n\\n// For UTF-16LE we do not explicitly append special replacement characters if we\\n// end on a partial character, we simply let v8 handle that.\\nfunction utf16End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) {\\n    var end = this.lastTotal - this.lastNeed;\\n    return r + this.lastChar.toString('utf16le', 0, end);\\n  }\\n  return r;\\n}\\n\\nfunction base64Text(buf, i) {\\n  var n = (buf.length - i) % 3;\\n  if (n === 0) return buf.toString('base64', i);\\n  this.lastNeed = 3 - n;\\n  this.lastTotal = 3;\\n  if (n === 1) {\\n    this.lastChar[0] = buf[buf.length - 1];\\n  } else {\\n    this.lastChar[0] = buf[buf.length - 2];\\n    this.lastChar[1] = buf[buf.length - 1];\\n  }\\n  return buf.toString('base64', i, buf.length - n);\\n}\\n\\nfunction base64End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\\n  return r;\\n}\\n\\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\\nfunction simpleWrite(buf) {\\n  return buf.toString(this.encoding);\\n}\\n\\nfunction simpleEnd(buf) {\\n  return buf && buf.length ? this.write(buf) : '';\\n}\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{fXKp:function(t,e,s){\"use strict\";var i=s(\"hwdV\").Buffer,a=i.isEncoding||function(t){switch((t=\"\"+t)&&t.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return!0;default:return!1}};function n(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return\"utf8\";for(var e;;)switch(t){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return t;default:if(e)return;t=(\"\"+t).toLowerCase(),e=!0}}(t);if(\"string\"!=typeof e&&(i.isEncoding===a||!a(t)))throw new Error(\"Unknown encoding: \"+t);return e||t}(t),this.encoding){case\"utf16le\":this.text=l,this.end=u,e=4;break;case\"utf8\":this.fillLast=h,e=4;break;case\"base64\":this.text=o,this.end=c,e=3;break;default:return this.write=f,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=i.allocUnsafe(e)}function r(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function h(t){var e=this.lastTotal-this.lastNeed,s=function(t,e,s){if(128!=(192&e[0]))return t.lastNeed=0,\"�\";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,\"�\";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,\"�\"}}(this,t);return void 0!==s?s:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function l(t,e){if((t.length-e)%2==0){var s=t.toString(\"utf16le\",e);if(s){var i=s.charCodeAt(s.length-1);if(i>=55296&&i<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],s.slice(0,-1)}return s}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString(\"utf16le\",e,t.length-1)}function u(t){var e=t&&t.length?this.write(t):\"\";if(this.lastNeed){var s=this.lastTotal-this.lastNeed;return e+this.lastChar.toString(\"utf16le\",0,s)}return e}function o(t,e){var s=(t.length-e)%3;return 0===s?t.toString(\"base64\",e):(this.lastNeed=3-s,this.lastTotal=3,1===s?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString(\"base64\",e,t.length-s))}function c(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+this.lastChar.toString(\"base64\",0,3-this.lastNeed):e}function f(t){return t.toString(this.encoding)}function d(t){return t&&t.length?this.write(t):\"\"}e.StringDecoder=n,n.prototype.write=function(t){if(0===t.length)return\"\";var e,s;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return\"\";s=this.lastNeed,this.lastNeed=0}else s=0;return s<t.length?e?e+this.text(t,s):this.text(t,s):e||\"\"},n.prototype.end=function(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+\"�\":e},n.prototype.text=function(t,e){var s=function(t,e,s){var i=e.length-1;if(i<s)return 0;var a=r(e[i]);if(a>=0)return a>0&&(t.lastNeed=a-1),a;if(--i<s||-2===a)return 0;if((a=r(e[i]))>=0)return a>0&&(t.lastNeed=a-2),a;if(--i<s||-2===a)return 0;if((a=r(e[i]))>=0)return a>0&&(2===a?a=0:t.lastNeed=a-3),a;return 0}(this,t,e);if(!this.lastNeed)return t.toString(\"utf8\",e);this.lastTotal=s;var i=t.length-(s-this.lastNeed);return t.copy(this.lastChar,0,i),t.toString(\"utf8\",e,i)},n.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}}}]);","extractedComments":[]}