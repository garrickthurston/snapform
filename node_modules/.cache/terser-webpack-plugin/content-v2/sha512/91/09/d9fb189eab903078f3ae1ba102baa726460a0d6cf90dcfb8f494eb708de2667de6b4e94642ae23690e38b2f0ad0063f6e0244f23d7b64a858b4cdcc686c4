{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\base64-js\\\\index.js\"],\"names\":[\"exports\",\"byteLength\",\"b64\",\"lens\",\"getLens\",\"validLen\",\"placeHoldersLen\",\"toByteArray\",\"tmp\",\"arr\",\"Arr\",\"_byteLength\",\"curByte\",\"len\",\"i\",\"revLookup\",\"charCodeAt\",\"fromByteArray\",\"uint8\",\"length\",\"extraBytes\",\"parts\",\"len2\",\"push\",\"encodeChunk\",\"lookup\",\"join\",\"Uint8Array\",\"Array\",\"code\",\"Error\",\"indexOf\",\"start\",\"end\",\"num\",\"output\"],\"mappings\":\"4FAEAA,EAAAC,WAuCA,SAAAC,GACA,IAAAC,EAAAC,EAAAF,GACAG,EAAAF,EAAA,GACAG,EAAAH,EAAA,GACA,OAAA,GAAAE,EAAAC,GAAA,EAAAA,GA1CAN,EAAAO,YAiDA,SAAAL,GAeA,IAdA,IAAAM,EACAL,EAAAC,EAAAF,GACAG,EAAAF,EAAA,GACAG,EAAAH,EAAA,GAEAM,EAAA,IAAAC,EAVA,SAAAR,EAAAG,EAAAC,GACA,OAAA,GAAAD,EAAAC,GAAA,EAAAA,EASAK,CAAAT,EAAAG,EAAAC,IAEAM,EAAA,EAGAC,EAAAP,EAAA,EACAD,EAAA,EACAA,EAEAS,EAAA,EAAiBA,EAAAD,EAASC,GAAA,EAC1BN,EACAO,EAAAb,EAAAc,WAAAF,KAAA,GACAC,EAAAb,EAAAc,WAAAF,EAAA,KAAA,GACAC,EAAAb,EAAAc,WAAAF,EAAA,KAAA,EACAC,EAAAb,EAAAc,WAAAF,EAAA,IACAL,EAAAG,KAAAJ,GAAA,GAAA,IACAC,EAAAG,KAAAJ,GAAA,EAAA,IACAC,EAAAG,KAAA,IAAAJ,EAGA,IAAAF,IACAE,EACAO,EAAAb,EAAAc,WAAAF,KAAA,EACAC,EAAAb,EAAAc,WAAAF,EAAA,KAAA,EACAL,EAAAG,KAAA,IAAAJ,GAGA,IAAAF,IACAE,EACAO,EAAAb,EAAAc,WAAAF,KAAA,GACAC,EAAAb,EAAAc,WAAAF,EAAA,KAAA,EACAC,EAAAb,EAAAc,WAAAF,EAAA,KAAA,EACAL,EAAAG,KAAAJ,GAAA,EAAA,IACAC,EAAAG,KAAA,IAAAJ,GAGA,OAAAC,GA1FAT,EAAAiB,cAiHA,SAAAC,GAQA,IAPA,IAAAV,EACAK,EAAAK,EAAAC,OACAC,EAAAP,EAAA,EACAQ,EAAA,GAIAP,EAAA,EAAAQ,EAAAT,EAAAO,EAA0CN,EAAAQ,EAAUR,GAHpD,MAIAO,EAAAE,KAAAC,EACAN,EAAAJ,EAAAA,EALA,MAKAQ,EAAAA,EAAAR,EALA,QAUA,IAAAM,GACAZ,EAAAU,EAAAL,EAAA,GACAQ,EAAAE,KACAE,EAAAjB,GAAA,GACAiB,EAAAjB,GAAA,EAAA,IACA,OAEG,IAAAY,IACHZ,GAAAU,EAAAL,EAAA,IAAA,GAAAK,EAAAL,EAAA,GACAQ,EAAAE,KACAE,EAAAjB,GAAA,IACAiB,EAAAjB,GAAA,EAAA,IACAiB,EAAAjB,GAAA,EAAA,IACA,MAIA,OAAAa,EAAAK,KAAA,KA1IA,IALA,IAAAD,EAAA,GACAV,EAAA,GACAL,EAAA,oBAAAiB,WAAAA,WAAAC,MAEAC,EAAA,mEACAf,EAAA,EAAAD,EAAAgB,EAAAV,OAAkCL,EAAAD,IAASC,EAC3CW,EAAAX,GAAAe,EAAAf,GACAC,EAAAc,EAAAb,WAAAF,IAAAA,EAQA,SAAAV,EAAAF,GACA,IAAAW,EAAAX,EAAAiB,OAEA,GAAAN,EAAA,EAAA,EACA,MAAA,IAAAiB,MAAA,kDAKA,IAAAzB,EAAAH,EAAA6B,QAAA,KAOA,OANA,IAAA1B,IAAAA,EAAAQ,GAMA,CAAAR,EAJAA,IAAAQ,EACA,EACA,EAAAR,EAAA,GAqEA,SAAAmB,EAAAN,EAAAc,EAAAC,GAGA,IAFA,IAAAzB,EARA0B,EASAC,EAAA,GACArB,EAAAkB,EAAqBlB,EAAAmB,EAASnB,GAAA,EAC9BN,GACAU,EAAAJ,IAAA,GAAA,WACAI,EAAAJ,EAAA,IAAA,EAAA,QACA,IAAAI,EAAAJ,EAAA,IACAqB,EAAAZ,KAdAE,GADAS,EAeA1B,IAdA,GAAA,IACAiB,EAAAS,GAAA,GAAA,IACAT,EAAAS,GAAA,EAAA,IACAT,EAAA,GAAAS,IAaA,OAAAC,EAAAT,KAAA,IAhGAX,EAAA,IAAAC,WAAA,IAAA,GACAD,EAAA,IAAAC,WAAA,IAAA\",\"sourcesContent\":[\"'use strict'\\n\\nexports.byteLength = byteLength\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\nfor (var i = 0, len = code.length; i < len; ++i) {\\n  lookup[i] = code[i]\\n  revLookup[code.charCodeAt(i)] = i\\n}\\n\\n// Support decoding URL-safe base64 strings, as Node.js does.\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\nrevLookup['-'.charCodeAt(0)] = 62\\nrevLookup['_'.charCodeAt(0)] = 63\\n\\nfunction getLens (b64) {\\n  var len = b64.length\\n\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // Trim off extra bytes after placeholder bytes are found\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\n  var validLen = b64.indexOf('=')\\n  if (validLen === -1) validLen = len\\n\\n  var placeHoldersLen = validLen === len\\n    ? 0\\n    : 4 - (validLen % 4)\\n\\n  return [validLen, placeHoldersLen]\\n}\\n\\n// base64 is 4/3 + up to two characters of the original data\\nfunction byteLength (b64) {\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction toByteArray (b64) {\\n  var tmp\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\n\\n  var curByte = 0\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  var len = placeHoldersLen > 0\\n    ? validLen - 4\\n    : validLen\\n\\n  for (var i = 0; i < len; i += 4) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\n      revLookup[b64.charCodeAt(i + 3)]\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 2) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 1) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] +\\n    lookup[num >> 12 & 0x3F] +\\n    lookup[num >> 6 & 0x3F] +\\n    lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp =\\n      ((uint8[i] << 16) & 0xFF0000) +\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\n      (uint8[i + 2] & 0xFF)\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(\\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\\n    ))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 2] +\\n      lookup[(tmp << 4) & 0x3F] +\\n      '=='\\n    )\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 10] +\\n      lookup[(tmp >> 4) & 0x3F] +\\n      lookup[(tmp << 2) & 0x3F] +\\n      '='\\n    )\\n  }\\n\\n  return parts.join('')\\n}\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{H7XF:function(r,t,n){\"use strict\";t.byteLength=function(r){var t=i(r),n=t[0],e=t[1];return 3*(n+e)/4-e},t.toByteArray=function(r){for(var t,n=i(r),e=n[0],h=n[1],c=new a(function(r,t,n){return 3*(t+n)/4-n}(0,e,h)),u=0,d=h>0?e-4:e,f=0;f<d;f+=4)t=o[r.charCodeAt(f)]<<18|o[r.charCodeAt(f+1)]<<12|o[r.charCodeAt(f+2)]<<6|o[r.charCodeAt(f+3)],c[u++]=t>>16&255,c[u++]=t>>8&255,c[u++]=255&t;2===h&&(t=o[r.charCodeAt(f)]<<2|o[r.charCodeAt(f+1)]>>4,c[u++]=255&t);1===h&&(t=o[r.charCodeAt(f)]<<10|o[r.charCodeAt(f+1)]<<4|o[r.charCodeAt(f+2)]>>2,c[u++]=t>>8&255,c[u++]=255&t);return c},t.fromByteArray=function(r){for(var t,n=r.length,o=n%3,a=[],h=0,c=n-o;h<c;h+=16383)a.push(d(r,h,h+16383>c?c:h+16383));1===o?(t=r[n-1],a.push(e[t>>2]+e[t<<4&63]+\"==\")):2===o&&(t=(r[n-2]<<8)+r[n-1],a.push(e[t>>10]+e[t>>4&63]+e[t<<2&63]+\"=\"));return a.join(\"\")};for(var e=[],o=[],a=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,h=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",c=0,u=h.length;c<u;++c)e[c]=h[c],o[h.charCodeAt(c)]=c;function i(r){var t=r.length;if(t%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var n=r.indexOf(\"=\");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function d(r,t,n){for(var o,a,h=[],c=t;c<n;c+=3)o=(r[c]<<16&16711680)+(r[c+1]<<8&65280)+(255&r[c+2]),h.push(e[(a=o)>>18&63]+e[a>>12&63]+e[a>>6&63]+e[63&a]);return h.join(\"\")}o[\"-\".charCodeAt(0)]=62,o[\"_\".charCodeAt(0)]=63}}]);","extractedComments":[]}