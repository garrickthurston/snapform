{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\ecdsa-sig-formatter\\\\src\\\\param-bytes-for-alg.js\",\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\ecdsa-sig-formatter\\\\src\\\\ecdsa-sig-formatter.js\"],\"names\":[\"getParamSize\",\"keySize\",\"paramBytesForAlg\",\"ES256\",\"ES384\",\"ES512\",\"module\",\"exports\",\"alg\",\"paramBytes\",\"Error\",\"Buffer\",\"__webpack_require__\",\"getParamBytesForAlg\",\"MAX_OCTET\",\"ENCODED_TAG_SEQ\",\"ENCODED_TAG_INT\",\"TAG_INT\",\"signatureAsBuffer\",\"signature\",\"isBuffer\",\"from\",\"TypeError\",\"countPadding\",\"buf\",\"start\",\"stop\",\"padding\",\"derToJose\",\"maxEncodedParamLength\",\"inputLength\",\"length\",\"offset\",\"seqLength\",\"rLength\",\"rOffset\",\"sLength\",\"sOffset\",\"rPadding\",\"sPadding\",\"dst\",\"allocUnsafe\",\"copy\",\"Math\",\"max\",\"o\",\"toString\",\"replace\",\"joseToDer\",\"signatureBytes\",\"rsBytes\",\"shortLength\"],\"mappings\":\"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\",\"sourcesContent\":[\"'use strict';\\n\\nfunction getParamSize(keySize) {\\n\\tvar result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);\\n\\treturn result;\\n}\\n\\nvar paramBytesForAlg = {\\n\\tES256: getParamSize(256),\\n\\tES384: getParamSize(384),\\n\\tES512: getParamSize(521)\\n};\\n\\nfunction getParamBytesForAlg(alg) {\\n\\tvar paramBytes = paramBytesForAlg[alg];\\n\\tif (paramBytes) {\\n\\t\\treturn paramBytes;\\n\\t}\\n\\n\\tthrow new Error('Unknown algorithm \\\"' + alg + '\\\"');\\n}\\n\\nmodule.exports = getParamBytesForAlg;\\n\",\"'use strict';\\n\\nvar Buffer = require('safe-buffer').Buffer;\\n\\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\\n\\nvar MAX_OCTET = 0x80,\\n\\tCLASS_UNIVERSAL = 0,\\n\\tPRIMITIVE_BIT = 0x20,\\n\\tTAG_SEQ = 0x10,\\n\\tTAG_INT = 0x02,\\n\\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\\n\\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\\n\\nfunction base64Url(base64) {\\n\\treturn base64\\n\\t\\t.replace(/=/g, '')\\n\\t\\t.replace(/\\\\+/g, '-')\\n\\t\\t.replace(/\\\\//g, '_');\\n}\\n\\nfunction signatureAsBuffer(signature) {\\n\\tif (Buffer.isBuffer(signature)) {\\n\\t\\treturn signature;\\n\\t} else if ('string' === typeof signature) {\\n\\t\\treturn Buffer.from(signature, 'base64');\\n\\t}\\n\\n\\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\\n}\\n\\nfunction derToJose(signature, alg) {\\n\\tsignature = signatureAsBuffer(signature);\\n\\tvar paramBytes = getParamBytesForAlg(alg);\\n\\n\\t// the DER encoded param should at most be the param size, plus a padding\\n\\t// zero, since due to being a signed integer\\n\\tvar maxEncodedParamLength = paramBytes + 1;\\n\\n\\tvar inputLength = signature.length;\\n\\n\\tvar offset = 0;\\n\\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\\n\\t\\tthrow new Error('Could not find expected \\\"seq\\\"');\\n\\t}\\n\\n\\tvar seqLength = signature[offset++];\\n\\tif (seqLength === (MAX_OCTET | 1)) {\\n\\t\\tseqLength = signature[offset++];\\n\\t}\\n\\n\\tif (inputLength - offset < seqLength) {\\n\\t\\tthrow new Error('\\\"seq\\\" specified length of \\\"' + seqLength + '\\\", only \\\"' + (inputLength - offset) + '\\\" remaining');\\n\\t}\\n\\n\\tif (signature[offset++] !== ENCODED_TAG_INT) {\\n\\t\\tthrow new Error('Could not find expected \\\"int\\\" for \\\"r\\\"');\\n\\t}\\n\\n\\tvar rLength = signature[offset++];\\n\\n\\tif (inputLength - offset - 2 < rLength) {\\n\\t\\tthrow new Error('\\\"r\\\" specified length of \\\"' + rLength + '\\\", only \\\"' + (inputLength - offset - 2) + '\\\" available');\\n\\t}\\n\\n\\tif (maxEncodedParamLength < rLength) {\\n\\t\\tthrow new Error('\\\"r\\\" specified length of \\\"' + rLength + '\\\", max of \\\"' + maxEncodedParamLength + '\\\" is acceptable');\\n\\t}\\n\\n\\tvar rOffset = offset;\\n\\toffset += rLength;\\n\\n\\tif (signature[offset++] !== ENCODED_TAG_INT) {\\n\\t\\tthrow new Error('Could not find expected \\\"int\\\" for \\\"s\\\"');\\n\\t}\\n\\n\\tvar sLength = signature[offset++];\\n\\n\\tif (inputLength - offset !== sLength) {\\n\\t\\tthrow new Error('\\\"s\\\" specified length of \\\"' + sLength + '\\\", expected \\\"' + (inputLength - offset) + '\\\"');\\n\\t}\\n\\n\\tif (maxEncodedParamLength < sLength) {\\n\\t\\tthrow new Error('\\\"s\\\" specified length of \\\"' + sLength + '\\\", max of \\\"' + maxEncodedParamLength + '\\\" is acceptable');\\n\\t}\\n\\n\\tvar sOffset = offset;\\n\\toffset += sLength;\\n\\n\\tif (offset !== inputLength) {\\n\\t\\tthrow new Error('Expected to consume entire buffer, but \\\"' + (inputLength - offset) + '\\\" bytes remain');\\n\\t}\\n\\n\\tvar rPadding = paramBytes - rLength,\\n\\t\\tsPadding = paramBytes - sLength;\\n\\n\\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\\n\\n\\tfor (offset = 0; offset < rPadding; ++offset) {\\n\\t\\tdst[offset] = 0;\\n\\t}\\n\\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\\n\\n\\toffset = paramBytes;\\n\\n\\tfor (var o = offset; offset < o + sPadding; ++offset) {\\n\\t\\tdst[offset] = 0;\\n\\t}\\n\\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\\n\\n\\tdst = dst.toString('base64');\\n\\tdst = base64Url(dst);\\n\\n\\treturn dst;\\n}\\n\\nfunction countPadding(buf, start, stop) {\\n\\tvar padding = 0;\\n\\twhile (start + padding < stop && buf[start + padding] === 0) {\\n\\t\\t++padding;\\n\\t}\\n\\n\\tvar needsSign = buf[start + padding] >= MAX_OCTET;\\n\\tif (needsSign) {\\n\\t\\t--padding;\\n\\t}\\n\\n\\treturn padding;\\n}\\n\\nfunction joseToDer(signature, alg) {\\n\\tsignature = signatureAsBuffer(signature);\\n\\tvar paramBytes = getParamBytesForAlg(alg);\\n\\n\\tvar signatureBytes = signature.length;\\n\\tif (signatureBytes !== paramBytes * 2) {\\n\\t\\tthrow new TypeError('\\\"' + alg + '\\\" signatures must be \\\"' + paramBytes * 2 + '\\\" bytes, saw \\\"' + signatureBytes + '\\\"');\\n\\t}\\n\\n\\tvar rPadding = countPadding(signature, 0, paramBytes);\\n\\tvar sPadding = countPadding(signature, paramBytes, signature.length);\\n\\tvar rLength = paramBytes - rPadding;\\n\\tvar sLength = paramBytes - sPadding;\\n\\n\\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\\n\\n\\tvar shortLength = rsBytes < MAX_OCTET;\\n\\n\\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\\n\\n\\tvar offset = 0;\\n\\tdst[offset++] = ENCODED_TAG_SEQ;\\n\\tif (shortLength) {\\n\\t\\t// Bit 8 has value \\\"0\\\"\\n\\t\\t// bits 7-1 give the length.\\n\\t\\tdst[offset++] = rsBytes;\\n\\t} else {\\n\\t\\t// Bit 8 of first octet has value \\\"1\\\"\\n\\t\\t// bits 7-1 give the number of additional length octets.\\n\\t\\tdst[offset++] = MAX_OCTET\\t| 1;\\n\\t\\t// length, base 256\\n\\t\\tdst[offset++] = rsBytes & 0xff;\\n\\t}\\n\\tdst[offset++] = ENCODED_TAG_INT;\\n\\tdst[offset++] = rLength;\\n\\tif (rPadding < 0) {\\n\\t\\tdst[offset++] = 0;\\n\\t\\toffset += signature.copy(dst, offset, 0, paramBytes);\\n\\t} else {\\n\\t\\toffset += signature.copy(dst, offset, rPadding, paramBytes);\\n\\t}\\n\\tdst[offset++] = ENCODED_TAG_INT;\\n\\tdst[offset++] = sLength;\\n\\tif (sPadding < 0) {\\n\\t\\tdst[offset++] = 0;\\n\\t\\tsignature.copy(dst, offset, paramBytes);\\n\\t} else {\\n\\t\\tsignature.copy(dst, offset, paramBytes + sPadding);\\n\\t}\\n\\n\\treturn dst;\\n}\\n\\nmodule.exports = {\\n\\tderToJose: derToJose,\\n\\tjoseToDer: joseToDer\\n};\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{LgVm:function(r,e,o){\"use strict\";function n(r){return(r/8|0)+(r%8==0?0:1)}var t={ES256:n(256),ES384:n(384),ES512:n(521)};r.exports=function(r){var e=t[r];if(e)return e;throw new Error('Unknown algorithm \"'+r+'\"')}},ij2l:function(r,e,o){\"use strict\";var n=o(\"hwdV\").Buffer,t=o(\"LgVm\"),i=128,f=48,a=2;function s(r){if(n.isBuffer(r))return r;if(\"string\"==typeof r)return n.from(r,\"base64\");throw new TypeError(\"ECDSA signature must be a Base64 string or a Buffer\")}function c(r,e,o){for(var n=0;e+n<o&&0===r[e+n];)++n;return r[e+n]>=i&&--n,n}r.exports={derToJose:function(r,e){r=s(r);var o=t(e),c=o+1,w=r.length,p=0;if(r[p++]!==f)throw new Error('Could not find expected \"seq\"');var u=r[p++];if(u===(1|i)&&(u=r[p++]),w-p<u)throw new Error('\"seq\" specified length of \"'+u+'\", only \"'+(w-p)+'\" remaining');if(r[p++]!==a)throw new Error('Could not find expected \"int\" for \"r\"');var l=r[p++];if(w-p-2<l)throw new Error('\"r\" specified length of \"'+l+'\", only \"'+(w-p-2)+'\" available');if(c<l)throw new Error('\"r\" specified length of \"'+l+'\", max of \"'+c+'\" is acceptable');var h=p;if(p+=l,r[p++]!==a)throw new Error('Could not find expected \"int\" for \"s\"');var d=r[p++];if(w-p!==d)throw new Error('\"s\" specified length of \"'+d+'\", expected \"'+(w-p)+'\"');if(c<d)throw new Error('\"s\" specified length of \"'+d+'\", max of \"'+c+'\" is acceptable');var g=p;if((p+=d)!==w)throw new Error('Expected to consume entire buffer, but \"'+(w-p)+'\" bytes remain');var E=o-l,v=o-d,b=n.allocUnsafe(E+l+v+d);for(p=0;p<E;++p)b[p]=0;r.copy(b,p,h+Math.max(-E,0),h+l);for(var m=p=o;p<m+v;++p)b[p]=0;return r.copy(b,p,g+Math.max(-v,0),g+d),b=(b=b.toString(\"base64\")).replace(/=/g,\"\").replace(/\\+/g,\"-\").replace(/\\//g,\"_\")},joseToDer:function(r,e){r=s(r);var o=t(e),w=r.length;if(w!==2*o)throw new TypeError('\"'+e+'\" signatures must be \"'+2*o+'\" bytes, saw \"'+w+'\"');var p=c(r,0,o),u=c(r,o,r.length),l=o-p,h=o-u,d=2+l+1+1+h,g=d<i,E=n.allocUnsafe((g?2:3)+d),v=0;return E[v++]=f,g?E[v++]=d:(E[v++]=1|i,E[v++]=255&d),E[v++]=a,E[v++]=l,p<0?(E[v++]=0,v+=r.copy(E,v,0,o)):v+=r.copy(E,v,p,o),E[v++]=a,E[v++]=h,u<0?(E[v++]=0,r.copy(E,v,o)):r.copy(E,v,o+u),E}}}}]);","extractedComments":[]}