{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\garrick\\\\source\\\\repos\\\\snapform\\\\node_modules\\\\jwa\\\\index.js\"],\"names\":[\"bufferEqual\",\"__webpack_require__\",\"Buffer\",\"crypto\",\"formatEcdsa\",\"util\",\"MSG_INVALID_SECRET\",\"MSG_INVALID_VERIFIER_KEY\",\"MSG_INVALID_SIGNER_KEY\",\"fromBase64\",\"base64\",\"replace\",\"toBase64\",\"base64url\",\"padding\",\"toString\",\"length\",\"i\",\"typeError\",\"template\",\"args\",\"slice\",\"call\",\"arguments\",\"errMsg\",\"format\",\"bind\",\"apply\",\"TypeError\",\"bufferOrString\",\"obj\",\"isBuffer\",\"normalizeInput\",\"thing\",\"JSON\",\"stringify\",\"createHmacSigner\",\"bits\",\"secret\",\"hmac\",\"createHmac\",\"update\",\"digest\",\"createHmacVerifier\",\"signature\",\"computedSig\",\"from\",\"createKeySigner\",\"privateKey\",\"signer\",\"createSign\",\"sign\",\"createKeyVerifier\",\"publicKey\",\"verifier\",\"createVerify\",\"verify\",\"createPSSKeySigner\",\"key\",\"constants\",\"RSA_PKCS1_PSS_PADDING\",\"createPSSKeyVerifier\",\"createECDSASigner\",\"inner\",\"derToJose\",\"createECDSAVerifer\",\"joseToDer\",\"createNoneSigner\",\"createNoneVerifier\",\"module\",\"exports\",\"algorithm\",\"signerFactories\",\"hs\",\"rs\",\"ps\",\"es\",\"none\",\"verifierFactories\",\"match\",\"algo\",\"toLowerCase\"],\"mappings\":\"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\",\"sourcesContent\":[\"var bufferEqual = require('buffer-equal-constant-time');\\nvar Buffer = require('safe-buffer').Buffer;\\nvar crypto = require('crypto');\\nvar formatEcdsa = require('ecdsa-sig-formatter');\\nvar util = require('util');\\n\\nvar MSG_INVALID_ALGORITHM = '\\\"%s\\\" is not a valid algorithm.\\\\n  Supported algorithms are:\\\\n  \\\"HS256\\\", \\\"HS384\\\", \\\"HS512\\\", \\\"RS256\\\", \\\"RS384\\\", \\\"RS512\\\", \\\"PS256\\\", \\\"PS384\\\", \\\"PS512\\\", \\\"ES256\\\", \\\"ES384\\\", \\\"ES512\\\" and \\\"none\\\".'\\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\\n\\nfunction fromBase64(base64) {\\n  return base64\\n    .replace(/=/g, '')\\n    .replace(/\\\\+/g, '-')\\n    .replace(/\\\\//g, '_');\\n}\\n\\nfunction toBase64(base64url) {\\n  base64url = base64url.toString();\\n\\n  var padding = 4 - base64url.length % 4;\\n  if (padding !== 4) {\\n    for (var i = 0; i < padding; ++i) {\\n      base64url += '=';\\n    }\\n  }\\n\\n  return base64url\\n    .replace(/\\\\-/g, '+')\\n    .replace(/_/g, '/');\\n}\\n\\nfunction typeError(template) {\\n  var args = [].slice.call(arguments, 1);\\n  var errMsg = util.format.bind(util, template).apply(null, args);\\n  return new TypeError(errMsg);\\n}\\n\\nfunction bufferOrString(obj) {\\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\\n}\\n\\nfunction normalizeInput(thing) {\\n  if (!bufferOrString(thing))\\n    thing = JSON.stringify(thing);\\n  return thing;\\n}\\n\\nfunction createHmacSigner(bits) {\\n  return function sign(thing, secret) {\\n    if (!bufferOrString(secret))\\n      throw typeError(MSG_INVALID_SECRET);\\n    thing = normalizeInput(thing);\\n    var hmac = crypto.createHmac('sha' + bits, secret);\\n    var sig = (hmac.update(thing), hmac.digest('base64'))\\n    return fromBase64(sig);\\n  }\\n}\\n\\nfunction createHmacVerifier(bits) {\\n  return function verify(thing, signature, secret) {\\n    var computedSig = createHmacSigner(bits)(thing, secret);\\n    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));\\n  }\\n}\\n\\nfunction createKeySigner(bits) {\\n return function sign(thing, privateKey) {\\n    if (!bufferOrString(privateKey) && !(typeof privateKey === 'object'))\\n      throw typeError(MSG_INVALID_SIGNER_KEY);\\n    thing = normalizeInput(thing);\\n    // Even though we are specifying \\\"RSA\\\" here, this works with ECDSA\\n    // keys as well.\\n    var signer = crypto.createSign('RSA-SHA' + bits);\\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\\n    return fromBase64(sig);\\n  }\\n}\\n\\nfunction createKeyVerifier(bits) {\\n  return function verify(thing, signature, publicKey) {\\n    if (!bufferOrString(publicKey))\\n      throw typeError(MSG_INVALID_VERIFIER_KEY);\\n    thing = normalizeInput(thing);\\n    signature = toBase64(signature);\\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\\n    verifier.update(thing);\\n    return verifier.verify(publicKey, signature, 'base64');\\n  }\\n}\\n\\nfunction createPSSKeySigner(bits) {\\n return function sign(thing, privateKey) {\\n    if (!bufferOrString(privateKey) && !(typeof privateKey === 'object'))\\n      throw typeError(MSG_INVALID_SIGNER_KEY);\\n    thing = normalizeInput(thing);\\n    var signer = crypto.createSign('RSA-SHA' + bits);\\n    var sig = (signer.update(thing), signer.sign({key: privateKey, padding: crypto.constants.RSA_PKCS1_PSS_PADDING}, 'base64'));\\n    return fromBase64(sig);\\n  }\\n}\\n\\nfunction createPSSKeyVerifier(bits) {\\n  return function verify(thing, signature, publicKey) {\\n    if (!bufferOrString(publicKey))\\n      throw typeError(MSG_INVALID_VERIFIER_KEY);\\n    thing = normalizeInput(thing);\\n    signature = toBase64(signature);\\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\\n    verifier.update(thing);\\n    return verifier.verify({key: publicKey, padding: crypto.constants.RSA_PKCS1_PSS_PADDING}, signature, 'base64');\\n  }\\n}\\n\\nfunction createECDSASigner(bits) {\\n  var inner = createKeySigner(bits);\\n  return function sign() {\\n    var signature = inner.apply(null, arguments);\\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\\n    return signature;\\n  };\\n}\\n\\nfunction createECDSAVerifer(bits) {\\n  var inner = createKeyVerifier(bits);\\n  return function verify(thing, signature, publicKey) {\\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\\n    var result = inner(thing, signature, publicKey);\\n    return result;\\n  };\\n}\\n\\nfunction createNoneSigner() {\\n  return function sign() {\\n    return '';\\n  }\\n}\\n\\nfunction createNoneVerifier() {\\n  return function verify(thing, signature) {\\n    return signature === '';\\n  }\\n}\\n\\nmodule.exports = function jwa(algorithm) {\\n  var signerFactories = {\\n    hs: createHmacSigner,\\n    rs: createKeySigner,\\n    ps: createPSSKeySigner,\\n    es: createECDSASigner,\\n    none: createNoneSigner,\\n  }\\n  var verifierFactories = {\\n    hs: createHmacVerifier,\\n    rs: createKeyVerifier,\\n    ps: createPSSKeyVerifier,\\n    es: createECDSAVerifer,\\n    none: createNoneVerifier,\\n  }\\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\\n  if (!match)\\n    throw typeError(MSG_INVALID_ALGORITHM, algorithm);\\n  var algo = (match[1] || match[3]).toLowerCase();\\n  var bits = match[2];\\n\\n  return {\\n    sign: signerFactories[algo](bits),\\n    verify: verifierFactories[algo](bits),\\n  }\\n};\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{eegf:function(r,n,e){var t=e(\"tc1l\"),o=e(\"hwdV\").Buffer,u=e(\"HEbw\"),i=e(\"ij2l\"),a=e(\"7tlc\"),f=\"secret must be a string or buffer\",c=\"key must be a string or a buffer\",s=\"key must be a string, a buffer or an object\";function S(r){return r.replace(/=/g,\"\").replace(/\\+/g,\"-\").replace(/\\//g,\"_\")}function p(r){var n=4-(r=r.toString()).length%4;if(4!==n)for(var e=0;e<n;++e)r+=\"=\";return r.replace(/\\-/g,\"+\").replace(/_/g,\"/\")}function g(r){var n=[].slice.call(arguments,1),e=a.format.bind(a,r).apply(null,n);return new TypeError(e)}function l(r){return o.isBuffer(r)||\"string\"==typeof r}function b(r){return l(r)||(r=JSON.stringify(r)),r}function v(r){return function(n,e){if(!l(e))throw g(f);n=b(n);var t=u.createHmac(\"sha\"+r,e);return S((t.update(n),t.digest(\"base64\")))}}function d(r){return function(n,e,u){var i=v(r)(n,u);return t(o.from(e),o.from(i))}}function w(r){return function(n,e){if(!l(e)&&\"object\"!=typeof e)throw g(s);n=b(n);var t=u.createSign(\"RSA-SHA\"+r);return S((t.update(n),t.sign(e,\"base64\")))}}function y(r){return function(n,e,t){if(!l(t))throw g(c);n=b(n),e=p(e);var o=u.createVerify(\"RSA-SHA\"+r);return o.update(n),o.verify(t,e,\"base64\")}}function h(r){return function(n,e){if(!l(e)&&\"object\"!=typeof e)throw g(s);n=b(n);var t=u.createSign(\"RSA-SHA\"+r);return S((t.update(n),t.sign({key:e,padding:u.constants.RSA_PKCS1_PSS_PADDING},\"base64\")))}}function A(r){return function(n,e,t){if(!l(t))throw g(c);n=b(n),e=p(e);var o=u.createVerify(\"RSA-SHA\"+r);return o.update(n),o.verify({key:t,padding:u.constants.RSA_PKCS1_PSS_PADDING},e,\"base64\")}}function m(r){var n=w(r);return function(){var e=n.apply(null,arguments);return e=i.derToJose(e,\"ES\"+r)}}function H(r){var n=y(r);return function(e,t,o){return t=i.joseToDer(t,\"ES\"+r).toString(\"base64\"),n(e,t,o)}}function P(){return function(){return\"\"}}function R(){return function(r,n){return\"\"===n}}r.exports=function(r){var n={hs:v,rs:w,ps:h,es:m,none:P},e={hs:d,rs:y,ps:A,es:H,none:R},t=r.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);if(!t)throw g('\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".',r);var o=(t[1]||t[3]).toLowerCase(),u=t[2];return{sign:n[o](u),verify:e[o](u)}}}}]);","extractedComments":[]}